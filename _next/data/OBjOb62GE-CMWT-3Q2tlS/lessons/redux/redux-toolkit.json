{"pageProps":{"post":{"attributes":{"description":""},"html":"<blockquote>\n<p>Please start with a fresh copy of this app: <a href=\"https://github.com/btholt/citr-v8-project/tree/master/14-context\">Adopt Me!</a></p>\n</blockquote>\n<p>Redux is a well-known library that does state management for you, very similarly to how we used context. With context, you use the provider and consumer as a sort of portal to skip passing parameters through every component. With Redux, we&#39;re taking the state management <em>out</em> of React entirely and moving it to a separate store.</p>\n<p>Why do we have Redux?</p>\n<ol>\n<li>Context used to be a lot worse to use and less useful. This made Redux (or Redux-like) management tools the only option</li>\n<li>Redux code is <em>extremely testable</em>. This is probably the most compelling reason to use it. Having your state mutation be broken up in such a way to make it easy to test is fantastic. This is also mitigated because we have <code>useReducer</code> now.</li>\n<li>The debugging story is very good.</li>\n</ol>\n<p>So given that we do now have the next context API, how often will I use Redux? That answer was previously &quot;never&quot; but now it&#39;s probably &quot;sometimes&quot; because of how good a project called Redux Toolkit is (which I will call RTK from now on, as does everyone else.) RTK took the hard parts of Redux and made them much more simple.</p>\n<p>Okay, let&#39;s get started. React state management is pretty simple: call setState and let React re-render. That&#39;s it! With plain Redux without RTK it used to be:</p>\n<ol>\n<li>User types in input box</li>\n<li>Call action creator to get an action</li>\n<li>Dispatch action to Redux</li>\n<li>Redux inserts the action into the root reducer</li>\n<li>The root reducer delegates that action to the correct reducer</li>\n<li>The reducer returns a new state given the old state and the action object</li>\n<li>That new state becomes the store&#39;s state</li>\n<li>React is then called by Redux and told to update</li>\n</ol>\n<p>So what was one step became several. But each step of this is testable, and that&#39;s great. And it&#39;s explicit and verbose. It&#39;s long to follow, but it&#39;s an easy breadcrumb trailer to follow when things go awry.</p>\n<p>But now it&#39;s much easier. RTK cuts out a lot of that boiler plate and made it much easier to write and not have to write all that boilerplate.</p>\n<p>So let&#39;s get started. Run</p>\n<pre><code class=\"language-bash\">npm install @reduxjs/toolkit@1.8.6 react-redux@8.0.4\n</code></pre>\n<p>Create store.js and put in it:</p>\n<pre><code class=\"language-javascript\">import { configureStore } from &quot;@reduxjs/toolkit&quot;;\n\nconst store = configureStore({\n  reducer: {},\n});\n\nexport default store;\n</code></pre>\n<p>In App.jsx</p>\n<pre><code class=\"language-javascript\">// delete AdoptedPetContext import\n// delete useState import from React\n\n// add import at top\nimport { Provider } from &quot;react-redux&quot;;\nimport store from &quot;./store&quot;;\n\n// delete useState call in function\n// delete &lt;AdoptedPetContext.Provder&gt; component\n\n// first component inside BrowserRouter\n&lt;Provider store={store}&gt;[…]&lt;/Provider&gt;;\n</code></pre>\n<p>This is the base store. The store is a centralized repo of data for your app. Think of it almost like a local database you can send queries and mutations too. It doesn&#39;t totally eclipse the need of local <code>useState</code> in React but it does in <em>some</em> of the cases. Typically it&#39;s going to be for app state sort of things. A general good rule of thumb is &quot;if this component unmounts, do I want to keep the state?&quot; If yes, might be app state and belongs in Redux. If no, probably not.</p>\n<p>So let&#39;s go make our existing context adopted pet in Redux instead of React context.</p>\n<ul>\n<li>Delete AdoptedPetContext.js</li>\n<li>Create adoptedPetSlice.js</li>\n</ul>\n<p>In there put:</p>\n<pre><code class=\"language-javascript\">import { createSlice } from &quot;@reduxjs/toolkit&quot;;\n\nexport const adoptedPetSlice = createSlice({\n  name: &quot;adoptedPet&quot;,\n  initialState: {\n    value: null,\n  },\n  reducers: {\n    adopt: (state, action) =&gt; {\n      state.value = action.payload;\n    },\n  },\n});\n\nexport const { adopt } = adoptedPetSlice.actions;\n\nexport default adoptedPetSlice.reducer;\n</code></pre>\n<ul>\n<li>Here you name your slice (what we&#39;re calling a bundle of reducers, state, and action creators)</li>\n<li>You give it an initial state</li>\n<li>You give it any reducers we need in our case, we just want a simple action that sets whatever the payload is to be what&#39;s stored. This common. Sometimes you may want to do some processing or math or something like that.</li>\n<li>RTK takes the liberty of making action creators and the actual reducers for you. This was something you used to have to code by hand.</li>\n<li>We export the reducer to use in the store.js file.</li>\n</ul>\n<p>Okay let&#39;s go <em>use this</em>. Go back to store.js</p>\n<pre><code class=\"language-javascript\">import { configureStore } from &quot;@reduxjs/toolkit&quot;;\nimport adoptedPet from &quot;./adoptedPetSlice&quot;;\n\nconst store = configureStore({\n  reducer: {\n    adoptedPet,\n  },\n});\n\nexport default store;\n</code></pre>\n<p>Add the reducer from the slice we created.</p>\n<p>Okay, now in Details.jsx</p>\n<pre><code class=\"language-javascript\">// add at top\n// delete import AdoptedPetContext from &quot;./AdoptedPetContext&quot;;\nimport { useState } from &quot;react&quot;; // drop useContext\nimport { useDispatch } from &quot;react-redux&quot;;\nimport { adopt } from &quot;./adoptedPetSlice&quot;;\n\n// delete the next two lines\n// eslint-disable-next-line no-unused-vars\n// const [_, setAdoptedPet] = useContext(AdoptedPetContext);\n\n// add with the hooks at the top\nconst dispatch = useDispatch();\n\n// replace setAdoptedPet\n&lt;button\n  onClick={() =&gt; {\n    dispatch(adopt(pet));\n    navigate(&quot;/&quot;);\n  }}\n&gt;\n  […]\n&lt;/button&gt;;\n</code></pre>\n<p>This is how to use Redux from a write perspective (we&#39;ll look at read in a sec.) You use <code>dispatch</code> functions to dispatch an action (which <code>adopt</code> does for us). That payload will eventually be passed to the reducer we made which will update our store. Redux handles all of the informing React of when to re-render. If this feels a lot like context is because it works much the same way. They both inspired each others&#39; design.</p>\n<p>Okay, let&#39;s go do writing. Hop on over to SearchParams.js</p>\n<pre><code class=\"language-jsx\">// delete import AdoptedPetContext from &quot;./AdoptedPetContext&quot;;\n\nimport { useState } from &quot;react&quot;; // drop useContext\nimport { useSelector } from &quot;react-redux&quot;;\n\n// delete const [adoptedPet] = useContext(AdoptedPetContext);\nconst adoptedPet = useSelector((state) =&gt; state.adoptedPet.value);\n</code></pre>\n<p>That&#39;s it! You give <code>useSelector</code> a function that takes in the entire state tree and gives back just what you need. Keep in mind this is a subscription function: it will use this function to judge whether or not it needs to re-render your component. So don&#39;t just give it <code>state =&gt; state</code> or else it&#39;ll re-render on <em>every state change ever</em> which is likely not what you want.</p>\n<p>Again, this is all fairly similar to Context but it definitely has its upsides. Slices are easy to test. And it externalize React&#39;s app state management from React itself. This means you can treat state mutation separately from UI which is generally a good thing. RTK made this much more palatable.</p>\n","slug":"redux-toolkit","title":"Redux Toolkit","section":"Redux","icon":"database","filePath":"/home/runner/work/complete-intro-to-react-v8/complete-intro-to-react-v8/lessons/14-redux/A-redux-toolkit.md","nextSlug":"/lessons/redux/more-app-state","prevSlug":"/lessons/typescript/refactor-app"}},"__N_SSG":true}