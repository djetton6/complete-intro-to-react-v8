{"pageProps":{"post":{"attributes":{"description":"Brian quickly converts Details.tsx"},"html":"<p>Let&#39;s go fix another file. Details.tsx. Before we get into the file, make a new file called <code>APIResponsesTypes.ts</code>. In there put</p>\n<pre><code class=\"language-typescript\">export type Animal = &quot;dog&quot; | &quot;cat&quot; | &quot;bird&quot; | &quot;reptile&quot; | &quot;rabbit&quot;;\n\nexport interface Pet {\n  id: number;\n  name: string;\n  animal: Animal;\n  description: string;\n  breed: string;\n  images: string[];\n  city: string;\n  state: string;\n}\n\nexport interface PetAPIResponse {\n  numberOfResults: number;\n  startIndex: number;\n  endIndex: number;\n  hasNext: boolean;\n  pets: Pet[];\n}\n</code></pre>\n<ul>\n<li>This allows us to resuse these response types anywhere we reference the API responses and have an enforceable shape that TypeScript knows what to do with.</li>\n<li>We made <code>Animal</code> a type instead of an interface. This confuses people a lot and the sum of the answer is it frequently doesn&#39;t matter which you choose. The general advice is &quot;use interfaces unless you need type aliases&quot;. Here we wanted to have a type alias that just allows a few different strings, something an interface can&#39;t do but a type can.</li>\n</ul>\n<p>Onto Details. Rename it Details.tsx</p>\n<pre><code class=\"language-tsx\">// grab the type\nimport { PetAPIResponse } from &quot;./APIResponsesTypes&quot;;\n\n// replace at top of render function\nif (!id) {\n  throw new Error(&quot;no id provided to details&quot;);\n}\nconst results = useQuery&lt;PetAPIResponse&gt;([&quot;details&quot;, id], fetchPet);\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst [_, setAdoptedPet] = useContext(AdoptedPetContext);\n\n// replace pet declaration\nconst pet = results?.data?.pets[0];\nif (!pet) {\n  throw new Error(&quot;pet not found&quot;);\n}\n\n// remove {...props} and props parameter from the DetailsErrorBoundary component\n</code></pre>\n<ul>\n<li>We need to type our query response with a generic.</li>\n<li>If ID comes back as undefined we have to exit this route. We can use the error boundary to help us out here.</li>\n<li>The unused-var rule is augmented in the TypeScript version so we have to update our ignore.</li>\n<li>Since we can come back as undefined or something else, we do have to account for &quot;what if it loads but it&#39;s not a pet?&quot; In this case we&#39;re just going to lean into our error boundary.</li>\n<li>We either need to type props or get rid of them. While I liked the seamless pass through, TypeScript requires you to be explicit all the time.</li>\n</ul>\n","slug":"refactor-details","title":"Refactor Details","section":"TypeScript","icon":"pencil-ruler","filePath":"/home/runner/work/complete-intro-to-react-v8/complete-intro-to-react-v8/lessons/13-typescript/C-refactor-details.md","nextSlug":"/lessons/typescript/refactor-adopted-pet-context","prevSlug":"/lessons/typescript/typescript-and-eslint"}},"__N_SSG":true}